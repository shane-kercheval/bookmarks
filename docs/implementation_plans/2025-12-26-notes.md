# Notes Feature Implementation Plan

**Date:** 2025-12-26
**Status:** Ready for Review
**Scope:** Add Notes functionality with full CRUD, unified navigation, and MCP integration

---

## Guiding Principles

These principles MUST guide all implementation decisions:

1. **No Legacy Code** - Delete and refactor, never work around. No backwards compatibility hacks.
2. **Single Source of Truth** - No duplicated logic. Extract shared patterns.
3. **Consistent Patterns** - Notes follows identical patterns to Bookmarks, not a bolted-on afterthought.
4. **Thorough Testing** - Every service function, endpoint, and component gets tests. Test edge cases and error conditions.
5. **Clean Abstractions** - Extract shared logic (tags, soft delete, archive) into reusable modules only when duplication emerges.
6. **Gold Standard Architecture** - Our design should be the standard others strive towards.
7. **Ask, Don't Assume** - When requirements are ambiguous, ask for clarification before implementing.

---

## Architecture Decisions

### What We're Building NOW

1. **Note Model** - Similar to Bookmark but without URL, with required title
2. **NoteVersion Table** - Schema only (empty), designed for diff-based history
3. **ContentList Refactor** - Rename BookmarkList, add `content_types` field
4. **Unified Navigation** - New sidebar structure with shared/type-specific sections
5. **Notes UI** - Full-page view/edit (not modal), markdown rendering
6. **MCP Tools** - `search_notes`, `get_note`, `create_note`, unified `search_content`

### What We're Building LATER (Not in this plan)

1. **Version History Logic** - Actually saving diffs and reconstructing versions
2. **Bulk Operations** - Bulk archive/delete
3. **Todos** - Third content type (future expansion)
4. **Tabbed Note Editor** - Multiple notes open simultaneously

### Version History Architecture (Design Now, Implement Later)

We will create the `NoteVersion` table NOW with the correct schema for diff-based storage:

```python
class NoteVersion(Base):
    id: int
    note_id: int (FK -> Note, CASCADE)
    version: int  # Sequential version number
    version_type: str  # "snapshot" | "diff"
    content: Text  # Full content if snapshot, diff if diff
    saved_at: DateTime
```

**Future strategy (not implemented now):**
- Every Nth save (e.g., 10) = full snapshot
- In-between saves = diff only (using diff-match-patch library)
- To reconstruct version X: find nearest prior snapshot, apply diffs forward

The `Note` model will include a `version: int` field (starting at 1) to track current version.

---

## Content Length Limits

- **Bookmarks:** 500KB content limit (existing)
- **Notes:** 2MB content limit (confirmed) - allows for long-form documents

---

## Markdown Rendering

**For viewing (render mode):**
- `react-markdown` - renders markdown to React components
- `remark-gfm` - GitHub Flavored Markdown support (tables, strikethrough, task lists)
- `rehype-sanitize` - XSS protection (required for security)

**For editing:**
- `@uiw/react-codemirror` - React wrapper for CodeMirror 6
- `@codemirror/lang-markdown` - Markdown language support with syntax highlighting

**Rationale:**
- CodeMirror provides syntax highlighting while editing (headers, bold, code blocks, links)
- Better handling of large documents
- Built-in undo/redo, search/replace
- `@uiw/react-codemirror` makes integration simple
- Fallback: If CodeMirror introduces unforeseen complexity, we can fall back to a simple textarea

**npm packages to install:**
```bash
npm install react-markdown remark-gfm rehype-sanitize @uiw/react-codemirror @codemirror/lang-markdown
```

**Basic CodeMirror usage:**
```tsx
import CodeMirror from '@uiw/react-codemirror';
import { markdown } from '@codemirror/lang-markdown';

<CodeMirror
  value={content}
  onChange={(value) => setContent(value)}
  extensions={[markdown()]}
  height="400px"
/>
```

---

## Navigation Structure

The new sidebar structure:

```
Sidebar:
|-- --------------------------
|   SHARED                    # Section label (not collapsible)
|-- --------------------------
|-- Research                  # Shared list (bookmarks + notes)
|-- Work Projects             # Shared list
|-- All                       # All content types
|-- Archived                  # All archived (with type filter)
|-- Trash                     # All deleted (with type filter)
|-- --------------------------
|   BOOKMARKS                 # Section label (collapsible)
|-- --------------------------
|-- All Bookmarks             # Built-in
|-- Reading List              # Bookmark-only custom list
|-- --------------------------
|   NOTES                     # Section label (collapsible)
|-- --------------------------
|-- All Notes                 # Built-in
|-- Meeting Notes             # Note-only custom list
```

**Ordering:** Both sections and items within sections are user-configurable.

---

## Data Model Changes

### New `tab_order` Format

Current format:
```json
["list:123", "all", "archived", "trash"]
```

New format:
```json
{
  "sections": {
    "shared": ["list:456", "all", "archived", "trash"],
    "bookmarks": ["all-bookmarks", "list:123"],
    "notes": ["all-notes", "list:234"]
  },
  "section_order": ["shared", "bookmarks", "notes"]
}
```

### ContentList Model (renamed from BookmarkList)

```python
class ContentList(Base, TimestampMixin):
    __tablename__ = "content_lists"  # New table name

    id: int
    user_id: int (FK -> User, CASCADE)
    name: str (max 100)
    content_types: list[str]  # JSONB: ["bookmark"], ["note"], ["bookmark", "note"]
    filter_expression: JSONB  # Existing tag filter logic
    default_sort_by: str | None
    default_sort_ascending: bool | None
```

---

## Milestones

---

### Milestone 1: Note Model and Database Schema

**Goal:** Create the Note model, NoteVersion table (schema only), and note_tags junction table.

**Dependencies:** None

**Success Criteria:**
- [ ] `Note` model exists with all fields
- [ ] `NoteVersion` model exists (empty, for future use)
- [ ] `note_tags` junction table exists
- [ ] Alembic migration runs successfully
- [ ] All models have proper indexes and constraints
- [ ] Unit tests verify model creation and relationships

**Key Changes:**

1. Create `backend/src/models/note.py`:
   ```python
   class Note(Base, TimestampMixin):
       __tablename__ = "notes"

       id: Mapped[int] = mapped_column(primary_key=True)
       user_id: Mapped[int] = mapped_column(ForeignKey("users.id", ondelete="CASCADE"), index=True)
       title: Mapped[str] = mapped_column(String(500))  # Required, unlike bookmark
       content: Mapped[str | None] = mapped_column(Text, nullable=True)  # Markdown, up to 2MB
       version: Mapped[int] = mapped_column(default=1)  # For future version history
       last_used_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=func.now(), index=True)
       deleted_at: Mapped[datetime | None] = mapped_column(DateTime(timezone=True), nullable=True, index=True)
       archived_at: Mapped[datetime | None] = mapped_column(DateTime(timezone=True), nullable=True)

       # Relationships
       user: Mapped["User"] = relationship("User", back_populates="notes")
       tag_objects: Mapped[list["Tag"]] = relationship("Tag", secondary="note_tags", ...)
   ```

2. Create `backend/src/models/note_version.py`:
   ```python
   class NoteVersion(Base):
       """Schema for future version history. Not actively used yet."""
       __tablename__ = "note_versions"

       id: Mapped[int] = mapped_column(primary_key=True)
       note_id: Mapped[int] = mapped_column(ForeignKey("notes.id", ondelete="CASCADE"), index=True)
       version: Mapped[int]
       version_type: Mapped[str] = mapped_column(String(20))  # "snapshot" | "diff"
       content: Mapped[str] = mapped_column(Text)
       saved_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=func.now())
   ```

3. Create `note_tags` junction table (similar to `bookmark_tags`)

4. Update `backend/src/models/__init__.py` to export new models

5. Update `User` model to add `notes` relationship

6. Create Alembic migration

**Testing Strategy:**
- Test Note model creation with all field types
- Test Note-Tag many-to-many relationship
- Test cascade delete (user deletion removes notes)
- Test NoteVersion model exists (even if unused)
- Verify indexes exist on key query fields

**Risk Factors:**
- Ensure 2MB content limit is enforced at database level if needed
- Junction table naming consistency with existing patterns

---

### Milestone 2: Note Schemas

**Goal:** Create Pydantic schemas for Note CRUD operations.

**Dependencies:** Milestone 1

**Success Criteria:**
- [ ] `NoteCreate`, `NoteUpdate`, `NoteListItem`, `NoteResponse` schemas exist
- [ ] Validation matches bookmark patterns (tag normalization, length limits)
- [ ] 2MB content limit enforced
- [ ] All schemas have comprehensive tests

**Key Changes:**

1. Create `backend/src/schemas/note.py`:
   ```python
   class NoteCreate(BaseModel):
       title: str  # Required
       content: str | None = None
       tags: list[str] = []
       archived_at: datetime | None = None

       # Validators for title length, content length (2MB), tag normalization

   class NoteUpdate(BaseModel):
       title: str | None = None
       content: str | None = None
       tags: list[str] | None = None
       archived_at: datetime | None = None

   class NoteListItem(BaseModel):
       """For list views - excludes content for performance."""
       id: int
       title: str
       tags: list[str]
       created_at: datetime
       updated_at: datetime
       last_used_at: datetime
       deleted_at: datetime | None
       archived_at: datetime | None
       version: int
       # Note: NO content field

   class NoteResponse(NoteListItem):
       """Full note detail including content."""
       content: str | None
   ```

2. Update `backend/src/schemas/__init__.py`

3. Add `max_note_content_length: int = 2_000_000` to `core/config.py`

**Testing Strategy:**
- Test tag validation (lowercase, hyphen format)
- Test title length validation
- Test content length validation (up to 2MB, reject larger)
- Test archived_at timezone handling
- Test NoteListItem excludes content
- Test model_validate from ORM objects

**Risk Factors:**
- Ensure validators match bookmark schema patterns exactly for consistency

---

### Milestone 3: Note Service Layer

**Goal:** Create the note service with full CRUD, search, archive, and soft delete.

**Dependencies:** Milestones 1, 2

**Success Criteria:**
- [ ] `create_note`, `get_note`, `update_note`, `delete_note` functions
- [ ] `search_notes` with text search, tag filtering, sorting, pagination
- [ ] `archive_note`, `unarchive_note`, `restore_note` functions
- [ ] All edge cases handled (not found, already deleted, etc.)
- [ ] Comprehensive test coverage

**Key Changes:**

1. Create `backend/src/services/note_service.py`:
   - Mirror `bookmark_service.py` patterns exactly
   - Functions:
     - `create_note(session, user_id, note_data) -> Note`
     - `get_note(session, user_id, note_id) -> Note | None`
     - `get_notes(session, user_id, ...) -> tuple[list[Note], int]` (with search/filter/sort/pagination)
     - `update_note(session, user_id, note_id, note_data) -> Note`
     - `delete_note(session, user_id, note_id) -> None` (soft delete)
     - `restore_note(session, user_id, note_id) -> Note`
     - `archive_note(session, user_id, note_id) -> Note`
     - `unarchive_note(session, user_id, note_id) -> Note`
   - Full-text search on title + content
   - Tag filtering with AND/OR modes
   - Reuse `build_filter_from_expression()` pattern from bookmark_service

2. Add custom exceptions in service or dedicated exceptions file:
   - `NoteNotFoundError`
   - `InvalidNoteStateError`

**Testing Strategy:**
- Test CRUD operations for notes
- Test search with query text
- Test tag filtering (AND mode, OR mode)
- Test sorting by all supported fields
- Test pagination (offset, limit, total count)
- Test soft delete (deleted_at set, not actually removed)
- Test restore from trash
- Test archive/unarchive
- Test user isolation (user A cannot see user B's notes)
- Test cascade delete when user is deleted

**Risk Factors:**
- Full-text search index may need specific handling for large content
- Ensure query performance with proper indexes

---

### Milestone 4: Note API Endpoints

**Goal:** Create the REST API endpoints for notes.

**Dependencies:** Milestone 3

**Success Criteria:**
- [ ] All CRUD endpoints work correctly
- [ ] Proper authentication (Auth0 + PAT)
- [ ] Rate limiting applied
- [ ] OpenAPI documentation generated
- [ ] Integration tests pass

**Key Changes:**

1. Create `backend/src/api/routers/notes.py`:
   ```python
   router = APIRouter(prefix="/notes", tags=["notes"])

   @router.post("/", response_model=NoteResponse, status_code=201)
   @router.get("/", response_model=NoteListResponse)
   @router.get("/{note_id}", response_model=NoteResponse)
   @router.patch("/{note_id}", response_model=NoteResponse)
   @router.delete("/{note_id}", status_code=204)
   @router.post("/{note_id}/archive", response_model=NoteResponse)
   @router.post("/{note_id}/unarchive", response_model=NoteResponse)
   @router.post("/{note_id}/restore", response_model=NoteResponse)
   ```

2. Register router in `backend/src/api/main.py`

3. Apply rate limiting:
   - Read operations: standard read tier
   - Write operations: standard write tier
   - No "sensitive" tier needed (no external HTTP requests)

**Testing Strategy:**
- Test all endpoints with valid requests
- Test authentication (401 without token)
- Test authorization (403 for wrong user's notes)
- Test validation errors (400 for invalid input)
- Test not found (404)
- Test rate limiting headers present
- Test pagination parameters
- Test search query parameter
- Test tag filtering parameters

**Risk Factors:**
- Ensure router prefix doesn't conflict with existing routes

---

### Milestone 5: ContentList Refactor (Backend)

**Goal:** Rename BookmarkList to ContentList and add content_types field.

**Dependencies:** Milestone 4

**Success Criteria:**
- [ ] `BookmarkList` model renamed to `ContentList`
- [ ] `bookmark_lists` table renamed to `content_lists`
- [ ] `content_types` field added with proper migration
- [ ] Existing lists migrated with `content_types: ["bookmark"]`
- [ ] Service and router updated
- [ ] All bookmark list functionality still works
- [ ] Tests updated and passing

**Key Changes:**

1. Rename model file: `bookmark_list.py` -> `content_list.py`

2. Update model:
   ```python
   class ContentList(Base, TimestampMixin):
       __tablename__ = "content_lists"

       # ... existing fields ...
       content_types: Mapped[list[str]] = mapped_column(
           JSONB,
           nullable=False,
           default=["bookmark"],
           comment="Content types this list applies to: bookmark, note, todo",
       )
   ```

3. Create Alembic migration:
   - Rename table `bookmark_lists` -> `content_lists`
   - Add `content_types` column with default `["bookmark"]`
   - Update existing rows to have `["bookmark"]`

4. Rename service: `bookmark_list_service.py` -> `content_list_service.py`
   - Update all function names and references
   - Add `content_types` parameter to create/update

5. Rename router: `routers/lists.py` stays but update internals
   - Endpoint paths stay at `/lists/`

6. Update schemas: `bookmark_list.py` -> `content_list.py`
   - Add `content_types` field to create/update/response schemas

7. Update User model relationship: `bookmark_lists` -> `content_lists`

8. Update all imports throughout codebase

**Testing Strategy:**
- Test existing list functionality still works
- Test creating list with single content type
- Test creating list with multiple content types
- Test filtering lists by content type
- Test migration runs correctly
- Test existing lists have content_types: ["bookmark"]

**Risk Factors:**
- This is a breaking change - all frontend code referencing "BookmarkList" must update
- Ensure all foreign key references update correctly

---

### Milestone 6: Tab Order Migration (Backend)

**Goal:** Migrate tab_order to new structured format supporting sections.

**Dependencies:** Milestone 5

**Success Criteria:**
- [ ] New tab_order format supported
- [ ] Migration converts existing data
- [ ] Settings service updated
- [ ] API handles new format
- [ ] Old format no longer supported (clean break)

**Key Changes:**

1. Update `UserSettings` model:
   - No schema change needed (JSONB is flexible)
   - Document new format in comments

2. Create migration to transform existing data:
   ```python
   # Old: ["list:123", "all", "archived", "trash"]
   # New: {
   #   "sections": {
   #     "shared": ["all", "archived", "trash"],
   #     "bookmarks": ["all-bookmarks", "list:123"],
   #     "notes": ["all-notes"]
   #   },
   #   "section_order": ["shared", "bookmarks", "notes"]
   # }
   ```

3. Update `settings_service.py`:
   - `get_tab_order()` returns new format
   - `update_tab_order()` accepts new format
   - `add_list_to_tab_order()` updated for sections
   - `remove_list_from_tab_order()` updated for sections

4. Update `user_settings` schema:
   - Define new TabOrder structure with proper Pydantic models

5. Update settings router endpoints

**Testing Strategy:**
- Test migration converts old format correctly
- Test new users get default structured tab_order
- Test adding list to correct section (based on content_types)
- Test removing list from section
- Test section ordering
- Test item ordering within section

**Risk Factors:**
- Data migration must handle edge cases (null tab_order, malformed data)
- Frontend must update simultaneously

---

### Milestone 7: Notes Frontend - Types and API Client

**Goal:** Add TypeScript types and API client functions for notes.

**Dependencies:** Milestone 4

**Success Criteria:**
- [ ] Note types defined in types.ts
- [ ] API client functions for all note endpoints
- [ ] Types match backend schemas exactly

**Key Changes:**

1. Update `frontend/src/types.ts`:
   ```typescript
   export interface NoteListItem {
     id: number
     title: string
     tags: string[]
     created_at: string
     updated_at: string
     last_used_at: string
     deleted_at: string | null
     archived_at: string | null
     version: number
   }

   export interface Note extends NoteListItem {
     content: string | null
   }

   export interface NoteCreate {
     title: string
     content?: string | null
     tags?: string[]
     archived_at?: string | null
   }

   export interface NoteUpdate {
     title?: string
     content?: string | null
     tags?: string[]
     archived_at?: string | null
   }

   export interface NoteListResponse {
     items: NoteListItem[]
     total: number
     offset: number
     limit: number
     has_more: boolean
   }
   ```

2. Update `frontend/src/services/api.ts`:
   - Add note API functions matching bookmark patterns

3. Update ContentList types:
   ```typescript
   export interface ContentList {
     id: number
     name: string
     content_types: ('bookmark' | 'note')[]
     filter_expression: FilterExpression
     default_sort_by: string | null
     default_sort_ascending: boolean | null
   }
   ```

**Testing Strategy:**
- Type checking via TypeScript compiler
- Verify API functions return expected types

**Risk Factors:**
- Keep types in sync with backend schemas

---

### Milestone 8: Notes Frontend - Hooks and Store

**Goal:** Create React hooks and Zustand stores for notes.

**Dependencies:** Milestone 7

**Success Criteria:**
- [ ] `useNotesQuery` hook with TanStack Query
- [ ] `useNoteMutations` hook (create, update, delete, archive, etc.)
- [ ] `useNotes` hook for non-cached utilities
- [ ] Query invalidation works correctly

**Key Changes:**

1. Create `frontend/src/hooks/useNotes.ts`:
   - `fetchNote(id)` - get full note with content
   - `trackNoteUsage(id)` - update last_used_at

2. Create `frontend/src/hooks/useNotesQuery.ts`:
   - Mirror `useBookmarksQuery.ts` pattern
   - Cache note list queries
   - Same stale time configuration

3. Create `frontend/src/hooks/useNoteMutations.ts`:
   - `useCreateNote()`
   - `useUpdateNote()`
   - `useDeleteNote()`
   - `useArchiveNote()`
   - `useUnarchiveNote()`
   - `useRestoreNote()`
   - Invalidate queries on mutation

4. Consider if notes need separate tag filter store or can share with bookmarks
   - Recommendation: Share `useTagFilterStore` (tags are cross-type)

**Testing Strategy:**
- Test hooks return expected data shapes
- Test mutation invalidation
- Test error handling in hooks

**Risk Factors:**
- Query key design must allow proper invalidation

---

### Milestone 9: Notes Frontend - Components

**Goal:** Create the Note UI components.

**Dependencies:** Milestone 8

**Success Criteria:**
- [ ] `NoteCard` component for list view
- [ ] `NoteView` component for rendered markdown view
- [ ] `NoteEditor` component for editing
- [ ] Components handle all states (loading, error, empty)

**Key Changes:**

1. Create `frontend/src/components/NoteCard.tsx`:
   - Similar to BookmarkCard but without URL/favicon
   - Shows title, truncated content preview, tags, dates
   - Context-aware actions (edit, archive, delete, restore)

2. Create `frontend/src/components/NoteView.tsx`:
   - Renders markdown content
   - Shows title, tags, metadata
   - Edit button to switch modes
   - Use a markdown rendering library (e.g., `react-markdown` with `remark-gfm`)
   - **Security:** Sanitize HTML output (use `rehype-sanitize`)

3. Create `frontend/src/components/NoteEditor.tsx`:
   - CodeMirror editor with markdown syntax highlighting (`@uiw/react-codemirror`)
   - Title input field
   - Tag input (reuse existing `TagInput` component)
   - Save and Cancel buttons
   - Optional: Preview toggle (side-by-side or switch)
   - Autosave draft to localStorage (recovery on crash)
   - Keyboard shortcuts: Cmd+S to save, Esc to cancel
   - Fallback: If CodeMirror causes issues, can replace with simple textarea

4. Create `frontend/src/components/NoteForm.tsx`:
   - Wrapper that coordinates view/edit modes
   - Handles API calls for save

**Testing Strategy:**
- Test NoteCard renders all states
- Test NoteView renders markdown correctly
- Test NoteEditor form submission
- Test keyboard shortcuts
- Test draft recovery

**Risk Factors:**
- Markdown rendering security (XSS prevention)
- Large content performance in editor

---

### Milestone 10: Notes Frontend - Pages

**Goal:** Create the Notes page with list and detail views.

**Dependencies:** Milestone 9

**Success Criteria:**
- [ ] `/app/notes` - Notes list view
- [ ] `/app/notes/:id` - Note view mode
- [ ] `/app/notes/:id/edit` - Note edit mode
- [ ] `/app/notes/new` - Create new note
- [ ] Search, filter, sort, pagination working
- [ ] Navigation between list and detail works

**Key Changes:**

1. Create `frontend/src/pages/Notes.tsx`:
   - Mirror Bookmarks.tsx structure
   - Search input with debounce
   - Tag filter (reuse TagFilterInput)
   - View selector (Active/Archived/Deleted)
   - Sort controls
   - Pagination
   - Note list with NoteCard components
   - "New Note" button

2. Create `frontend/src/pages/NoteDetail.tsx`:
   - Route: `/app/notes/:id` and `/app/notes/:id/edit`
   - Back button to return to list
   - Renders NoteView or NoteEditor based on route/mode
   - Save navigates to view mode
   - Cancel returns to view mode (or list if new)

3. Update `frontend/src/App.tsx` (or router config):
   - Add routes for notes pages

**Testing Strategy:**
- Test list renders correctly
- Test navigation to detail view
- Test edit mode toggle
- Test create new note flow
- Test search updates results
- Test pagination controls
- Test view switching (active/archived/deleted)

**Risk Factors:**
- Route structure must be intuitive
- State management between list and detail views

---

### Milestone 11: Sidebar Refactor (Frontend)

**Goal:** Implement new unified navigation structure with sections.

**Dependencies:** Milestones 6, 10

**Success Criteria:**
- [ ] New sidebar structure with SHARED, BOOKMARKS, NOTES sections
- [ ] Section ordering configurable
- [ ] Item ordering within sections configurable
- [ ] Collapsible type-specific sections (BOOKMARKS, NOTES)
- [ ] Non-collapsible SHARED section
- [ ] Lists appear in correct section based on content_types

**Key Changes:**

1. Update `frontend/src/components/sidebar/Sidebar.tsx`:
   - Render sections based on new tab_order format
   - SHARED section: non-collapsible, contains shared lists + All/Archived/Trash
   - BOOKMARKS section: collapsible, contains bookmark-only lists + All Bookmarks
   - NOTES section: collapsible, contains note-only lists + All Notes

2. Update `frontend/src/stores/settingsStore.ts`:
   - Parse new tab_order format
   - Compute section data from format

3. Update `frontend/src/components/sidebar/routes.ts`:
   - Add note routes
   - Add section-aware route generation

4. Update icons:
   - Bookmark icon for bookmark-only items
   - Note icon for note-only items
   - Combined/collection icon for shared items

5. Update list creation modal to show content_types selection

**Testing Strategy:**
- Test sections render in correct order
- Test items within sections render in correct order
- Test collapsible sections work
- Test navigation to correct routes
- Test list appears in correct section based on content_types

**Risk Factors:**
- Complex state management for section ordering
- Need to handle migration from old sidebar structure

---

### Milestone 12: MCP Tools for Notes

**Goal:** Add MCP tools for notes and unified search.

**Dependencies:** Milestone 4

**Success Criteria:**
- [ ] `search_notes` tool works
- [ ] `get_note` tool works
- [ ] `create_note` tool works
- [ ] `search_content` unified tool works
- [ ] MCP server instructions updated

**Key Changes:**

1. Update `backend/src/mcp_server/server.py`:

   ```python
   @mcp.tool(description="Search notes with optional text query and tag filtering.")
   async def search_notes(
       query: str | None = None,
       tags: list[str] | None = None,
       tag_match: Literal["all", "any"] = "all",
       sort_by: Literal["created_at", "updated_at", "last_used_at", "title"] = "created_at",
       sort_order: Literal["asc", "desc"] = "desc",
       limit: int = 50,
       offset: int = 0,
   ) -> dict[str, Any]: ...

   @mcp.tool(description="Get full details of a specific note including content.")
   async def get_note(note_id: int) -> dict[str, Any]: ...

   @mcp.tool(description="Create a new note.")
   async def create_note(
       title: str,
       content: str | None = None,
       tags: list[str] | None = None,
   ) -> dict[str, Any]: ...

   @mcp.tool(description="Search across all content types (bookmarks, notes).")
   async def search_content(
       query: str | None = None,
       content_types: list[Literal["bookmark", "note"]] = ["bookmark", "note"],
       tags: list[str] | None = None,
       tag_match: Literal["all", "any"] = "all",
       sort_by: str = "created_at",
       sort_order: Literal["asc", "desc"] = "desc",
       limit: int = 50,
       offset: int = 0,
   ) -> dict[str, Any]:
       """
       Unified search across content types.
       Returns results GROUPED BY TYPE with separate pagination per type.
       Frontend can choose to display separately or interleave.
       """
   ```

   **Unified search response structure (grouped by type with separate pagination):**
   ```json
   {
     "bookmarks": {
       "items": [...],
       "total": 45,
       "offset": 0,
       "limit": 50,
       "has_more": false
     },
     "notes": {
       "items": [...],
       "total": 12,
       "offset": 0,
       "limit": 50,
       "has_more": false
     }
   }
   ```

2. Update MCP server instructions to document new tools

3. Add API client functions for notes in `mcp_server/api_client.py` if needed

**Testing Strategy:**
- Test each tool with valid inputs
- Test error handling (not found, invalid parameters)
- Test unified search returns both types
- Test unified search with type filtering
- Test authentication works

**Risk Factors:**
- Unified search may need backend endpoint or combine results in MCP layer

---

### Milestone 13: Settings and List Management Updates

**Goal:** Update settings pages for new list/content structure.

**Dependencies:** Milestones 5, 6, 11

**Success Criteria:**
- [ ] "Bookmarks" settings renamed to "Lists" or "Custom Lists"
- [ ] List creation allows selecting content_types
- [ ] List editing allows updating content_types
- [ ] Tab order editor works with new format

**Key Changes:**

1. Update settings navigation:
   - Rename "Bookmarks" to "Lists" or "Custom Lists"

2. Update `ListModal.tsx`:
   - Add content_types selector (checkboxes for bookmark, note)
   - **Default to all types checked** for new lists (confirmed decision)

3. Update `TabOrderEditor.tsx`:
   - Handle new section-based format
   - Allow reordering sections
   - Allow reordering items within sections

4. Update `ListManager.tsx`:
   - Show content_types on list cards
   - Filter by content_type if needed

**Testing Strategy:**
- Test creating list with single content type
- Test creating list with multiple content types
- Test editing list content types
- Test tab order editing with sections
- Test section reordering

**Risk Factors:**
- Complex UI for section-aware ordering

---

### Milestone 14: Documentation and Cleanup

**Goal:** Update all documentation and ensure code quality.

**Dependencies:** All previous milestones

**Success Criteria:**
- [ ] CLAUDE.md updated with notes information
- [ ] API documentation accurate
- [ ] No dead code or unused imports
- [ ] Consistent naming throughout
- [ ] All tests passing
- [ ] Linting clean

**Key Changes:**

1. Update `CLAUDE.md`:
   - Add notes endpoints documentation
   - Update rate limiting table if changed
   - Document new navigation structure
   - Document MCP tools for notes

2. Remove any backwards compatibility code

3. Run linting and fix issues:
   - `make linting` for backend
   - `npm run lint` for frontend

4. Review for dead code:
   - Old BookmarkList references
   - Old tab_order format handling
   - Unused imports

5. Ensure test coverage:
   - Run `make tests`
   - Verify coverage for new code

**Testing Strategy:**
- Full test suite passes
- Manual testing of all flows
- Review documentation accuracy

**Risk Factors:**
- May discover edge cases during final testing

---

## Summary

| Milestone | Description | Backend | Frontend | MCP |
|-----------|-------------|---------|----------|-----|
| 1 | Note Model & DB Schema | Yes | - | - |
| 2 | Note Schemas | Yes | - | - |
| 3 | Note Service Layer | Yes | - | - |
| 4 | Note API Endpoints | Yes | - | - |
| 5 | ContentList Refactor | Yes | - | - |
| 6 | Tab Order Migration | Yes | - | - |
| 7 | Frontend Types & API | - | Yes | - |
| 8 | Frontend Hooks & Store | - | Yes | - |
| 9 | Frontend Components | - | Yes | - |
| 10 | Frontend Pages | - | Yes | - |
| 11 | Sidebar Refactor | - | Yes | - |
| 12 | MCP Tools | Yes | - | Yes |
| 13 | Settings Updates | - | Yes | - |
| 14 | Documentation & Cleanup | Yes | Yes | Yes |

---

## Resolved Questions

All questions have been answered:

1. **Content length for notes:** 2MB confirmed
2. **Markdown editor:** CodeMirror (`@uiw/react-codemirror`) for editing with syntax highlighting + react-markdown/remark-gfm/rehype-sanitize for viewing. Fallback to textarea if CodeMirror causes issues.
3. **Unified search format:** Grouped by type with separate pagination per type. Frontend can choose to display separately or interleave.
4. **Default list behavior:** Default to all content types checked when creating new lists.
