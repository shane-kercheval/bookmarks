# MCP Server Implementation Plan

## Overview

This plan implements a Model Context Protocol (MCP) server that wraps the bookmarks API, enabling AI agents (e.g., Claude Desktop, Claude Code) to interact with bookmarks using Personal Access Tokens (PATs) for authentication.

**Key Architecture Decision**: MCP is a thin wrapper around the existing API. It makes HTTP calls to the API, passing through the Bearer token. The API handles all authentication and business logic. This ensures a single source of truth - UI, API users, and MCP all use the same interface.

### Goals
- Expose bookmark functionality as MCP tools
- Authenticate via existing PAT system (`bm_` prefixed tokens) - handled by API
- HTTP transport for both local dev and production
- Provide tools for: searching bookmarks, getting bookmark details, creating bookmarks, and listing tags

### Non-Goals (Out of Scope)
- OAuth integration (PAT-only authentication)
- Deleting/archiving bookmarks via MCP
- Fetching URL metadata via MCP
- MCP Resources or Prompts (tools only for initial implementation)

---

## Documentation References

**Read these before implementing:**
- FastMCP Documentation: https://gofastmcp.com/servers/tools
- FastMCP HTTP Deployment: https://gofastmcp.com/deployment/http
- FastMCP Testing: https://gofastmcp.com/patterns/testing
- MCP Protocol Overview: https://modelcontextprotocol.io/docs/learn/server-concepts
- MCP Inspector: https://modelcontextprotocol.io/docs/tools/inspector

---

## Milestone 1: Project Setup and API Client

### Goal
Set up the MCP server infrastructure with an HTTP client that forwards requests to the existing API. MCP is a thin wrapper - the API handles all authentication and business logic.

### Success Criteria
- FastMCP server initializes and runs via HTTP
- API client can make authenticated requests to the bookmarks API
- Bearer token is extracted from MCP request and forwarded to API
- MCP Inspector can connect and list tools

### Key Changes

1. **Add dependencies**
   ```bash
   uv add fastmcp httpx
   ```

2. **Create MCP server module** (`backend/src/mcp/`)
   ```
   backend/src/mcp/
   ├── __init__.py
   ├── __main__.py       # Entry point
   ├── server.py         # FastMCP server instance and tools
   └── api_client.py     # HTTP client for API calls
   ```

3. **Create API client** (`backend/src/mcp/api_client.py`)

   Async HTTP client that forwards Bearer tokens to the API:
   ```python
   import httpx
   import os

   API_BASE_URL = os.getenv("API_BASE_URL", "http://localhost:8000")

   class APIClient:
       def __init__(self, token: str):
           self.token = token
           self.base_url = API_BASE_URL

       def _headers(self) -> dict[str, str]:
           return {"Authorization": f"Bearer {self.token}"}

       async def get(self, path: str, params: dict | None = None) -> dict:
           async with httpx.AsyncClient() as client:
               response = await client.get(
                   f"{self.base_url}{path}",
                   params=params,
                   headers=self._headers(),
               )
               response.raise_for_status()
               return response.json()

       async def post(self, path: str, json: dict) -> dict:
           async with httpx.AsyncClient() as client:
               response = await client.post(
                   f"{self.base_url}{path}",
                   json=json,
                   headers=self._headers(),
               )
               response.raise_for_status()
               return response.json()
   ```

4. **Create FastMCP server instance** (`backend/src/mcp/server.py`)
   ```python
   from fastmcp import FastMCP

   mcp = FastMCP(name="Bookmarks MCP Server")
   ```

5. **Create entry point** (`backend/src/mcp/__main__.py`)
   ```python
   from .server import mcp

   if __name__ == "__main__":
       mcp.run(transport="http", host="0.0.0.0", port=8001)
   ```

### Testing Strategy
- Unit test API client with mocked httpx responses
- Integration test: MCP server starts and responds to tool listing
- Test with MCP Inspector: `npx @modelcontextprotocol/inspector uv run python -m backend.src.mcp`

### Dependencies
- None (first milestone)

### Risk Factors
- Need to verify how to extract Bearer token from MCP request context
- API must be running for MCP to work (document this requirement)

---

## Milestone 2: Core Tools Implementation

### Goal
Implement the four core MCP tools that wrap API endpoints: `search_bookmarks`, `get_bookmark`, `create_bookmark`, and `list_tags`.

### Success Criteria
- All four tools are registered and callable via MCP
- Tools make HTTP calls to the corresponding API endpoints
- API errors are translated to meaningful MCP errors
- Tools work with valid PAT, fail appropriately with invalid PAT

### Key Changes

1. **Implement `search_bookmarks` tool**
   ```python
   from typing import Annotated
   from pydantic import Field
   from fastmcp import Context
   from fastmcp.exceptions import ToolError
   from .api_client import APIClient

   def get_api_client(ctx: Context) -> APIClient:
       # Extract Bearer token from MCP request
       # The exact method depends on FastMCP's API - verify in docs
       token = ctx.request_context.access_token.token
       return APIClient(token)

   @mcp.tool(
       description="Search bookmarks with optional text query and tag filtering",
       annotations={"readOnlyHint": True}
   )
   async def search_bookmarks(
       ctx: Context,
       query: Annotated[str | None, "Text to search in title, URL, description, and content"] = None,
       tags: Annotated[list[str] | None, "Filter by tags (bookmark must have ALL specified tags)"] = None,
       limit: Annotated[int, Field(ge=1, le=100, description="Maximum results to return")] = 20,
       offset: Annotated[int, Field(ge=0, description="Number of results to skip")] = 0,
   ) -> dict:
       """Search and filter bookmarks."""
       client = get_api_client(ctx)
       params = {"limit": limit, "offset": offset}
       if query:
           params["q"] = query
       if tags:
           params["tags"] = ",".join(tags)

       try:
           return await client.get("/bookmarks/", params)
       except httpx.HTTPStatusError as e:
           raise ToolError(f"API error: {e.response.status_code}")
   ```

2. **Implement `get_bookmark` tool**
   ```python
   @mcp.tool(
       description="Get the full details of a specific bookmark including content",
       annotations={"readOnlyHint": True}
   )
   async def get_bookmark(
       ctx: Context,
       bookmark_id: Annotated[int, "The ID of the bookmark to retrieve"],
   ) -> dict:
       """Get a bookmark by ID."""
       client = get_api_client(ctx)
       try:
           return await client.get(f"/bookmarks/{bookmark_id}")
       except httpx.HTTPStatusError as e:
           if e.response.status_code == 404:
               raise ToolError(f"Bookmark with ID {bookmark_id} not found")
           raise ToolError(f"API error: {e.response.status_code}")
   ```

3. **Implement `create_bookmark` tool**
   ```python
   @mcp.tool(
       description="Create a new bookmark. URL metadata (title, description) will be auto-fetched if not provided.",
       annotations={"readOnlyHint": False}
   )
   async def create_bookmark(
       ctx: Context,
       url: Annotated[str, "The URL to bookmark"],
       title: Annotated[str | None, "Title (auto-fetched if not provided)"] = None,
       description: Annotated[str | None, "Description (auto-fetched if not provided)"] = None,
       tags: Annotated[list[str] | None, "Tags to assign (lowercase alphanumeric with hyphens)"] = None,
       store_content: Annotated[bool, "Whether to store the page content"] = True,
   ) -> dict:
       """Create a new bookmark."""
       client = get_api_client(ctx)
       payload = {"url": url, "store_content": store_content}
       if title:
           payload["title"] = title
       if description:
           payload["description"] = description
       if tags:
           payload["tags"] = tags

       try:
           return await client.post("/bookmarks/", payload)
       except httpx.HTTPStatusError as e:
           if e.response.status_code == 409:
               raise ToolError("A bookmark with this URL already exists")
           raise ToolError(f"API error: {e.response.status_code}")
   ```

4. **Implement `list_tags` tool**
   ```python
   @mcp.tool(
       description="List all available tags with their usage counts",
       annotations={"readOnlyHint": True}
   )
   async def list_tags(ctx: Context) -> dict:
       """Get all tags for the authenticated user."""
       client = get_api_client(ctx)
       try:
           return await client.get("/tags/")
       except httpx.HTTPStatusError as e:
           raise ToolError(f"API error: {e.response.status_code}")
   ```

### Testing Strategy
- Unit tests for each tool with mocked API responses
- Test error handling: 401 (invalid token), 404 (not found), 409 (duplicate)
- Integration tests with real API running
- Test with MCP Inspector

### Dependencies
- Milestone 1 (API client)

### Risk Factors
- Extracting Bearer token from MCP context - verify FastMCP API
- Handling API error responses properly

---

## Milestone 3: HTTP Transport and Server Integration

### Goal
Configure the MCP server as an HTTP endpoint. Same transport for local dev and production.

### Success Criteria
- MCP server accessible via HTTP at `/mcp` endpoint
- Claude Desktop connects via Settings > Connectors
- Health check endpoint for monitoring

### Key Changes

1. **Update entry point** (`backend/src/mcp/__main__.py`)
   ```python
   from .server import mcp

   if __name__ == "__main__":
       mcp.run(
           transport="http",
           host="0.0.0.0",
           port=8001,
       )
   ```

   Run with: `uv run python -m backend.src.mcp`

2. **Claude Desktop Setup**
   1. Settings > Connectors
   2. Add custom connector
   3. URL: `http://localhost:8001/mcp` (dev) or `https://your-domain.com/mcp` (prod)
   4. Enter PAT as Bearer token when prompted

3. **Add health check endpoint**
   ```python
   from starlette.responses import JSONResponse

   @mcp.custom_route("/health", methods=["GET"])
   async def health_check(request):
       return JSONResponse({"status": "healthy", "service": "bookmarks-mcp"})
   ```

4. **Update Makefile**
   ```makefile
   mcp-run:
       uv run python -m backend.src.mcp

   mcp-dev:
       npx @modelcontextprotocol/inspector uv run python -m backend.src.mcp
   ```

### Testing Strategy
- Integration test: HTTP endpoint responds correctly
- Test with MCP Inspector
- Test Claude Desktop connection via Custom Connectors

### Dependencies
- Milestone 2 (tools)

### Risk Factors
- Port conflicts with main API (using 8001 vs 8000)
- For horizontal scaling, use `stateless_http=True`

---

## Milestone 4: Testing and Documentation

### Goal
Comprehensive test coverage and documentation for MCP functionality.

### Success Criteria
- Unit test coverage for all MCP components
- Integration tests for tool execution
- Usage documentation for Claude Desktop setup
- README section on MCP usage

### Key Changes

1. **Create test module** (`backend/tests/mcp/`)
   ```
   backend/tests/mcp/
   ├── __init__.py
   ├── conftest.py           # MCP-specific fixtures
   ├── test_api_client.py    # API client tests
   ├── test_tools.py         # Tool execution tests
   └── test_integration.py   # End-to-end tests
   ```

2. **Test fixtures** (`conftest.py`)
   ```python
   import pytest
   from fastmcp import Client
   from backend.src.mcp.server import mcp

   @pytest.fixture
   async def mcp_client():
       async with Client(transport=mcp) as client:
           yield client
   ```

3. **Tool tests** (`test_tools.py`)
   - Test `search_bookmarks` with various query/filter combinations
   - Test `get_bookmark` with valid/invalid IDs
   - Test `create_bookmark` with valid data, duplicates, validation errors
   - Test `list_tags` returns correct counts
   - Mock httpx responses to isolate from API

4. **Documentation updates**
   - Add MCP section to README.md
   - Document Claude Desktop setup (Settings > Connectors > Add custom connector)
   - Document PAT creation for MCP access
   - Document available tools and their parameters
   - Note: API must be running for MCP to work

### Testing Strategy
- Run full test suite: `make unit_tests`
- Verify MCP tests pass in CI
- Manual testing with Claude Desktop

### Dependencies
- Milestones 1-3

### Risk Factors
- Testing requires mocking httpx or running the API
- Ensure tests don't require actual API to be running

---

## Architecture Summary

```
┌─────────────────────────────────────────────────────────────┐
│                     Claude Desktop / AI Agent               │
└─────────────────────────────────────────────────────────────┘
                              │
                    PAT Token (Authorization: Bearer bm_xxx)
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    MCP Server (FastMCP)                      │
│                         Port 8001                            │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                    Tools (server.py)                    │ │
│  │  - search_bookmarks    - get_bookmark                   │ │
│  │  - create_bookmark     - list_tags                      │ │
│  └─────────────────────────────────────────────────────────┘ │
│                              │                               │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                 API Client (api_client.py)              │ │
│  │  - Forwards Bearer token to API                         │ │
│  │  - Translates API errors to MCP errors                  │ │
│  └─────────────────────────────────────────────────────────┘ │
│                              │                               │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │               HTTP Transport (Streamable)               │ │
│  └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                              │
                    HTTP (Bearer token forwarded)
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                   Bookmarks API (FastAPI)                    │
│                         Port 8000                            │
│  - Validates PAT tokens                                      │
│  - Handles all business logic                                │
│  - Single source of truth                                    │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                        PostgreSQL                            │
└─────────────────────────────────────────────────────────────┘
```

---

## File Structure

```
backend/src/
├── mcp/
│   ├── __init__.py
│   ├── __main__.py         # Entry point (runs HTTP server on port 8001)
│   ├── server.py           # FastMCP instance and tool definitions
│   └── api_client.py       # HTTP client for API calls
├── api/                     # Existing API (unchanged)
├── services/                # Existing services (used by API, not MCP directly)
└── ...

backend/tests/
├── mcp/
│   ├── __init__.py
│   ├── conftest.py
│   ├── test_api_client.py
│   ├── test_tools.py
│   └── test_integration.py
└── ...
```

---

## Implementation Notes

### Token Extraction
The exact method to extract the Bearer token from MCP context depends on FastMCP's API. Check the FastMCP documentation for:
- How clients send authentication headers
- How to access the token in tool functions via `Context`

Likely pattern:
```python
def get_api_client(ctx: Context) -> APIClient:
    token = ctx.request_context.access_token.token
    return APIClient(token)
```

### Error Handling
Translate HTTP errors to meaningful MCP errors:

```python
try:
    return await client.get(f"/bookmarks/{bookmark_id}")
except httpx.HTTPStatusError as e:
    if e.response.status_code == 401:
        raise ToolError("Invalid or expired token")
    if e.response.status_code == 404:
        raise ToolError(f"Bookmark {bookmark_id} not found")
    raise ToolError(f"API error: {e.response.status_code}")
```

### Running Both Servers
For development, you need both servers running:
```bash
# Terminal 1: API
make run  # Port 8000

# Terminal 2: MCP
make mcp-run  # Port 8001
```

### Environment Configuration
The MCP server needs to know the API URL:
```python
API_BASE_URL = os.getenv("API_BASE_URL", "http://localhost:8000")
```

For production, set this to your deployed API URL.
